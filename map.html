<!DOCTYPE html>
<html lang="en">
<head>
  <base target="_top">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>JalTara Pit Map</title>

  <link rel="shortcut icon" type="image/png"
        href="https://images.squarespace-cdn.com/content/686b6207a7c996116ca9f6cc/0e917f42-0227-4261-8ad4-d14e1a1febab/%C2%A92_Save+Groundwater_icon_original_HD_png.png?content-type=image%2Fpng" />

  <!-- leaflet css -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <!-- markercluster css -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

  <!-- fullscreen css -->
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/leaflet.fullscreen.css" />

  <!-- leaflet and markercluster js -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- fullscreen js -->
  <script src="https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/Leaflet.fullscreen.min.js"></script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    .leaflet-container {
      height: 800px;
      width: 1600px;
      max-width: 100%;
      max-height: 100%;
    }
    .invisible-cluster-icon {
    pointer-events: none; /* make the invisible icon unclickable */
    }
  </style>
</head>
<body>
  <div id="map" style="width: 1600px; height: 800px;"></div>

  <script>
    function toTitleCase(str) {
      str = str.split(' ');
      str = str.map(word => word.charAt(0).toUpperCase() + word.slice(1));
      return str.join(' ');
    }

    function clearMap() {
      expandedMarkers.forEach(m => {
        m.setIcon(clusterStyleIcon);
        m.bindPopup(m.villagePopup);
        m.closePopup();
      });
      expandedMarkers.length = 0;
  
      if (currentUnclusteredMarkers != null && currentCluster != null) {
        currentUnclusteredMarkers.remove();
        currentUnclusteredMarkers = null;
  
        map.addLayer(currentClusterGroup);
        
        currentClusterGroup = null;
        currentCluster = null;
      }
      
      boundsZoom = null;
    }

    // default cluster icon style (is a function given cluster)
    const defaultClusterIcon = function(cluster) {
      return L.divIcon({
        html: `<div style="
                  background:#009C9D;
                  color:white;
                  border-radius:50%;
                  border: 1px solid #004E4F;
                  width:40px;
                  height:40px;
                  display:flex;
                  align-items:center;
                  justify-content:center;
                  font-family: 'Courier New', monospace;
                  font-size:14px;">
                     ${cluster.getChildCount()}
                   </div>`,
        className: "village-cluster-icon",
        iconSize: [40, 40]
      });
    };
    
    // marker style that looks like cluster
    const clusterStyleIcon = L.divIcon({
      html: `<div style="
               background:#009C9D; 
               color:white; 
               border-radius:50%;
               border: 1px solid #004E4F;
               width:40px; 
               height:40px; 
               display:flex; 
               align-items:center; 
               justify-content:center; 
               font-family: 'Courier New', monospace;
               font-size:14px;">
               1
             </div>`,
      className: "village-cluster-icon",
      iconSize: [40, 40]
    });
    
    // icon style after expanding
    const expandedMarkerIcon = L.divIcon({
      html: `<div style="
               background:#80CECE; 
               border-radius:50%;
               border: 1px solid #009C9D;
               width:15px; 
               height:15px;">
             </div>`,
      className: "expanded-marker-icon",
      iconSize: [15, 15]
    });

    // invisible icon to hide things
    const invisibleClusterIcon = L.divIcon({
      html: `<div style="
               width:1px;
               height:1px;
               background-color: rgba(0,0,0,0);  /* fully transparent */
             "></div>`,
      className: "invisible-cluster-icon",
      iconSize: [1, 1]
    });

    const map = L.map('map', {
      center: [19.84529409208099, 76.27065167353523],
      zoom: 5,
      minZoom: 2,
      maxZoom: 18,
      worldCopyJump: false,   // prevent snapping across worlds
      maxBounds: [
        [-90, -180],  // southwest corner
        [90, 180]     // northeast corner
      ],
      fullscreenControl: true
    });

    // base layers
    const satellite = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Tiles &copy; Esri', maxZoom: 19 }
    ).addTo(map);

    const street = L.tileLayer(
      'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      { attribution: 'Â© OpenStreetMap contributors', maxZoom: 19 }
    );

    const labels = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Labels &copy; Esri', maxZoom: 19 }
    ).addTo(map);

    // toggle map view control
    const ToggleControl = L.Control.extend({
      onAdd: function(map) {
        const btn = L.DomUtil.create('button', '');
        let current = 'satellite';
        btn.innerHTML = "Street View";
        btn.style.backgroundColor = 'white';
        btn.style.padding = '5px';
        btn.style.cursor = 'pointer';
        btn.style.border = '1px solid gray';

        btn.onclick = function() {
          if (current == 'satellite') {
            map.removeLayer(satellite);
            street.addTo(map);
            current = 'street';
            btn.innerHTML = "Satellite View";
          } else {
            map.removeLayer(street);
            satellite.addTo(map);
            current = 'satellite';
            btn.innerHTML = "Street View";
          }
        };
        return btn;
      }
    });
    new ToggleControl({ position: 'topright' }).addTo(map);

    // bounds and cluster storage
    let minLat = Infinity, maxLat = -Infinity;
    let minLon = Infinity, maxLon = -Infinity;
    let clusters = {};

    // marker click global vars
    let boundsZoom = null;
    const expandedMarkers = [];

    // cluster click global vars
    let currentUnclusteredMarkers = null;
    let currentCluster = null;
    let currentClusterGroup = null;

    // fetch pit data
    fetch('https://raw.githubusercontent.com/savegroundwater/jaltara/d25ca6ebcef06176a284c7eb0c49c106f56f47ba/pit_data.txt')
      .then(res => res.text())
      .then(text => {
        const lines = text.trim().split('\n');
        lines.shift(); // remove header row

        lines.forEach(line => {
          const columns = line.split('\t');
          // make sure data is right
          const pitLat = parseFloat((columns[1] || '').trim()) || '';
          const pitLon = parseFloat((columns[2] || '').trim()) || '';
          const village = (columns[3] || '').trim() ? toTitleCase(columns[3].trim()) : '';
          const date = (columns[5] || '').trim();
          const image = (columns[6] || '').trim();
          
          if (!isNaN(pitLat) && !isNaN(pitLon)) {
            // track bounds
            minLat = Math.min(minLat, pitLat);
            maxLat = Math.max(maxLat, pitLat);
            minLon = Math.min(minLon, pitLon);
            maxLon = Math.max(maxLon, pitLon);

            // popup content
            let popupContent = '<div style="text-align:center;">';
            if (image && image !== '--') {
              popupContent += `
                <div style="width:150px; height:150px; overflow:hidden; margin:0 auto;">
                  <img src="${image}" style="width:150px; height:150px; object-fit:cover;">
                </div><br>
              `;
            }
            if (village && village !== '--') {
              popupContent += `<strong>Village:</strong> ${village}<br>`;
            }
            if (date && date !== '--') {
              popupContent += `<strong>Date:</strong> ${date}`;
            }
            popupContent += '</div>';

            const villagePopup = `<strong>Village:</strong> ${village}<br>`;

            // make the marker look like a cluster with only village in popup
            const marker = L.marker([pitLat, pitLon], { icon: clusterStyleIcon });
            marker.villageName = village;
            marker.villagePopup = villagePopup;
            marker.popupContent = popupContent;

            marker.bindPopup(marker.villagePopup);
            
            marker.on('mouseover', function() { this.openPopup(); });
            marker.on('mouseout', function() { this.closePopup(); });
            
// marker clicks
            marker.on('click', function() {
              if (currentCluster == null || marker.villageName != currentCluster.villageName) {
                clearMap();
                
                this.setIcon(expandedMarkerIcon);
                this.bindPopup(this.popupContent);
  
                const coords = this.getLatLng();
  
                map.flyTo([coords.lat, coords.lng], 16, { animate: true, duration: 0.5 });
                boundsZoom = 16;
                
                if (!expandedMarkers.includes(this)) {
                  expandedMarkers.push(this);       // add it to expandedMarkers if not already there
                }
              }
              });

// zoomend
            map.on('zoomend', function() {
              if (boundsZoom != null && map.getZoom() < (boundsZoom - 1)) {
                clearMap();
              }
            });

            // make sure cluster exists for village
            if (!clusters[village] && (currentCluster == null || currentCluster.villageName != village)) {
              clusters[village] = L.markerClusterGroup({
                maxClusterRadius: 999999,
                disableClusteringAtZoom: 20, // never uncluster - this is controlled manually in clusterclick event
                spiderfyOnMaxZoom: false,
                zoomToBoundsOnClick: true,
                showCoverageOnHover: false,
// cluster iconcreatefunction
                iconCreateFunction: function(cluster) {
                  return defaultClusterIcon(cluster);
                }
              });

              clusters[village].villageName = village;

              clusters[village].on('clustermouseover', function(e) {
                e.layer.bindPopup(`<b>Village:</b> ${village}`).openPopup();
              });

              clusters[village].on('clustermouseout', function(e) {
                e.layer.closePopup();
              });

// cluster clicks
              clusters[village].on('clusterclick', function(e) {
                clearMap();
                
                currentCluster = e.layer;
                currentCluster.villageName = village;
                currentClusterGroup = clusters[village];
                
                const currentMarkers = currentCluster.getAllChildMarkers(); // get all markers in this cluster
                currentMarkers.forEach(marker => {
                  marker.setIcon(expandedMarkerIcon);
                  marker.bindPopup(marker.popupContent);
                });

              map.removeLayer(currentClusterGroup);
                
              currentUnclusteredMarkers = L.layerGroup(currentMarkers);
              currentUnclusteredMarkers.addTo(map)

              map.flyToBounds(currentCluster.getBounds(), { padding: [50, 50], maxZoom: 18, animate: true, duration: 0.5 });
              boundsZoom = map.getBoundsZoom(currentCluster.getBounds());
              
              });
  
              map.addLayer(clusters[village]);
              
            }

            // add marker to that village's cluster
            clusters[village].addLayer(marker);

          }
        });

        // fit map to bounds
        const bounds = L.latLngBounds(
          L.latLng(minLat - 1, minLon - 1),
          L.latLng(maxLat + 1, maxLon + 1)
        );
        map.fitBounds(bounds);
      });
  </script>
</body>
</html>




