<!DOCTYPE html>
<html lang="en">
<head>
  <base target="_top">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>JalTara Pit Map</title>

  <link rel="shortcut icon" type="image/png"
        href="https://images.squarespace-cdn.com/content/686b6207a7c996116ca9f6cc/0e917f42-0227-4261-8ad4-d14e1a1febab/%C2%A92_Save+Groundwater_icon_original_HD_png.png?content-type=image%2Fpng" />

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <!-- Leaflet.markercluster CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    .leaflet-container {
      height: 800px;
      width: 1600px;
      max-width: 100%;
      max-height: 100%;
    }
    .invisible-cluster-icon {
    pointer-events: none; /* make the invisible icon unclickable */
    }
  </style>
</head>
<body>
  <div id="map" style="width: 1600px; height: 800px;"></div>

  <script>
    function toTitleCase(str) {
      str = str.split(' ');
      str = str.map(word => word.charAt(0).toUpperCase() + word.slice(1));
      return str.join(' ');
    }

    // default cluster icon style (is a function given cluster)
    const defaultClusterIcon = function(cluster) {
      return L.divIcon({
        html: `<div style="background:#4a90e2; color:white; border-radius:50%;
                           width:40px; height:40px; display:flex; align-items:center;
                           justify-content:center; font-size:14px;">
                     ${cluster.getChildCount()}
                   </div>`,
        className: "village-cluster-icon",
        iconSize: [40, 40]
      });
    };
    
    // marker style that looks like cluster
    const clusterStyleIcon = L.divIcon({
      html: `<div style="
               background:#4a90e2; 
               color:white; 
               border-radius:50%; 
               width:40px; 
               height:40px; 
               display:flex; 
               align-items:center; 
               justify-content:center; 
               font-size:14px;">
               1
             </div>`,
      className: "village-cluster-icon",
      iconSize: [40, 40]
    });
    
    // icon style after expanding
    const expandedMarkerIcon = L.divIcon({
      html: `<div style="
               background:#2a2a2a; 
               border-radius:50%; 
               width:20px; 
               height:20px;">
             </div>`,
      className: "expanded-marker-icon",
      iconSize: [20, 20]
    });

    // invisible icon to hide things
    const invisibleClusterIcon = L.divIcon({
      html: `<div style="
               width:40px;
               height:40px;
               background-color: rgba(0,0,0,0);  /* fully transparent */
             "></div>`,
      className: "invisible-cluster-icon",
      iconSize: [1, 1]
    });

    const map = L.map('map', {
      center: [19.84529409208099, 76.27065167353523],
      zoom: 5,
      minZoom: 2,
      maxZoom: 18
    });

    // base layers
    const satellite = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Tiles &copy; Esri', maxZoom: 19 }
    );

    const street = L.tileLayer(
      'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      { attribution: '© OpenStreetMap contributors', maxZoom: 19 }
    ).addTo(map);

    const labels = L.tileLayer(
      'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Labels &copy; Esri', maxZoom: 19 }
    ).addTo(map);

    // toggle map view control
    const ToggleControl = L.Control.extend({
      onAdd: function(map) {
        const btn = L.DomUtil.create('button', '');
        let current = 'street';
        btn.innerHTML = "Satellite View";
        btn.style.backgroundColor = 'white';
        btn.style.padding = '5px';
        btn.style.cursor = 'pointer';
        btn.style.border = '1px solid gray';

        btn.onclick = function() {
          if (current === 'satellite') {
            map.removeLayer(satellite);
            street.addTo(map);
            current = 'street';
            btn.innerHTML = "Satellite View";
          } else {
            map.removeLayer(street);
            satellite.addTo(map);
            current = 'satellite';
            btn.innerHTML = "Street View";
          }
        };
        return btn;
      }
    });
    new ToggleControl({ position: 'topright' }).addTo(map);

    // bounds and cluster storage
    let minLat = Infinity, maxLat = -Infinity;
    let minLon = Infinity, maxLon = -Infinity;
    let clusters = {};

    // marker click global vars
    let clickedZoom = null;
    const expandedMarkers = [];

    // cluster click global vars
    let currentUnclusteredMarkers = null;
    let currentCluster = null;

    // fetch pit data
    fetch('https://raw.githubusercontent.com/savegroundwater/jaltara/d25ca6ebcef06176a284c7eb0c49c106f56f47ba/pit_data.txt')
      .then(res => res.text())
      .then(text => {
        const lines = text.trim().split('\n');
        lines.shift(); // remove header row

        lines.forEach(line => {
          const columns = line.split('\t');
          const pitLat = parseFloat(columns[1]);
          const pitLon = parseFloat(columns[2]);
          const village = toTitleCase(columns[3]);
          const date = columns[5];
          const image = columns[6].trim();

          if (!isNaN(pitLat) && !isNaN(pitLon)) {
            // track bounds
            minLat = Math.min(minLat, pitLat);
            maxLat = Math.max(maxLat, pitLat);
            minLon = Math.min(minLon, pitLon);
            maxLon = Math.max(maxLon, pitLon);

            // popup content
            let popupContent = '<div style="text-align:center;">';
            if (image && image !== '..') {
              popupContent += `
                <div style="width:150px; height:150px; overflow:hidden; margin:0 auto;">
                  <img src="${image}" style="width:150px; height:150px; object-fit:cover;">
                </div><br>
              `;
            }
            if (village && village !== '..') {
              popupContent += `<strong>Village:</strong> ${village}<br>`;
            }
            if (date && date !== '..') {
              popupContent += `<strong>Date:</strong> ${date}`;
            }
            popupContent += '</div>';

            const villagePopup = `<strong>Village:</strong> ${village}<br>`;

            // make the marker look like a cluster with only village in popup
            const marker = L.marker([pitLat, pitLon], { icon: clusterStyleIcon });
            marker.bindPopup(villagePopup);
            
            marker.on('mouseover', function() { this.openPopup(); });
            marker.on('mouseout', function() { this.closePopup(); });
            marker.on('click', function() {
              this.setIcon(expandedMarkerIcon);
              this.bindPopup(popupContent);
              clickedZoom = map.getZoom();
              if (!expandedMarkers.includes(this)) {
                expandedMarkers.push(this);       // add it to expandedMarkers if not already there
              }
            });
            
            map.on('zoomend', function() {
              if (clickedZoom != null && map.getZoom() < clickedZoom) {
                expandedMarkers.forEach(m => {
                  m.setIcon(clusterStyleIcon);
                  m.bindPopup(villagePopup);
                  m.closePopup();
                });
                expandedMarkers.length = 0;

                if (currentUnclusteredMarkers != null && currentCluster != null) {
                  currentUnclusteredMarkers.remove();
                  currentUnclusteredMarkers = null;

                  currentCluster.setIcon(defaultClusterIcon(currentCluster));
                  currentCluster = null;
                }
                
                clickedZoom = null;
              }
            });

            // make sure cluster exists for village
            if (!clusters[village]) {
              clusters[village] = L.markerClusterGroup({
                maxClusterRadius: 999999,
                disableClusteringAtZoom: 20, // never disable clustering - i do this manually in clusterclick event
                spiderfyOnMaxZoom: false,
                zoomToBoundsOnClick: true,
                showCoverageOnHover: false,
                iconCreateFunction: function(cluster) {
                  // compare the cluster’s village property with currentCluster’s village
                  if (currentCluster && cluster.villageName == currentCluster.villageName) {
                    return invisibleClusterIcon;
                  }
                  return defaultClusterIcon(cluster);
                }
              });

              clusters[village].villageName = village;

              clusters[village].on('clustermouseover', function(e) {
                e.layer.bindPopup(`<b>Village:</b> ${village}`).openPopup();
              });

              clusters[village].on('clustermouseout', function(e) {
                e.layer.closePopup();
              });

              // handle cluster clicks
              clusters[village].on('clusterclick', function(e) {
                expandedMarkers.forEach(m => {
                  m.setIcon(clusterStyleIcon);
                  m.bindPopup(villagePopup);
                  m.closePopup();
                });
                expandedMarkers.length = 0;

                if (currentUnclusteredMarkers != null && currentCluster != null) {
                  currentUnclusteredMarkers.remove();
                  currentUnclusteredMarkers = null;

                  currentCluster.setIcon(defaultClusterIcon(currentCluster));
                  currentCluster = null;
                }
                
                clickedZoom = null;
                
                clickedZoom = map.getZoom();
                currentCluster = e.layer;
                
                const currentMarkers = currentCluster.getAllChildMarkers(); // get all markers in this cluster
                currentMarkers.forEach(marker => {
                  marker.setIcon(expandedMarkerIcon);
                  marker.bindPopup(popupContent);
                });

              currentCluster.setIcon(invisibleClusterIcon);
                
              currentUnclusteredMarkers = L.layerGroup(currentMarkers);
              currentUnclusteredMarkers.addTo(map);
                
              });
  
              map.addLayer(clusters[village]);
            }

            // add marker to that village's cluster
            clusters[village].addLayer(marker);

          }
        });

        // fit map to bounds
        const bounds = L.latLngBounds(
          L.latLng(minLat - 1, minLon - 1),
          L.latLng(maxLat + 1, maxLon + 1)
        );
        map.fitBounds(bounds);
      });
  </script>
</body>
</html>








